<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>画图</title>
  <style>
    canvas {
      border: 2px solid #f0f;
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
  <canvas width="400" height="300"></canvas>
</body>
<script>
  var cvs = document.querySelector('canvas')
  var ctx = cvs.getContext('2d')

  function dot(x, y, color = 'black') {
    ctx.fillStyle = color
    ctx.fillRect(x, y, 1, 1)
  }
</script>
<script>
  // YOUR CODE GOES HERE
  // 输出实线
  var x = 20
  var y = 20
  for (i = 20 ;i < 380;i++ ){
    dot(x,y,color='rgb(0,31,63)')
    // 'hsl(' + x + ',60%,60%)'
    x = x + 1
  }
  // 1个空点虚线
  var m = 20
  var n = 40
  for (i = 20; i < 200 ; i++){
    dot(m,n,color='rgb(0,31,63)')
    m = m + 2
  }
  //两个实点两个空点的虚线
  var p = 20
  var q = 60
  for (i = 0; i < 180 ; i++){
    for(j = 0; j < 2; j++){
      dot(p,q,color='rgb(255,220,0)')
      p = p + 1
    }
    p = p + 3
  }
  //三个实点两个空点的虚线
  /*  
   if (x % 15 < 4){
    dot(x,80)}else if (x%15<12){
    dot(x,80,"red")}
    */
  var s = 20
  var t = 80
  for (i = 0; i < 180 ; i++){
    for(j = 0; j < 3; j++){
      dot(s,t,color='rgb(255,220,0)')
      s = s + 1
    }
    s = s + 3
  }
  //45°斜线
  var f = 275
  var g = 80
  for (i = 20; i < 120 ; i++){
    dot(f,g,color='rgb(0,31,63)')
     //dot(f+1,g,color='rgb(0,31,63)') 画出来会粗一些
    f = f + 1
    g = g + 1
  }
  //对角线
  var e = 0
  var h = 0
  for (i = 0; i < 400 ; i++){
    dot(e,h,color='rgb(0,31,63)')
    e = e + 1
    h = h + 3/4
    /*
    for (x = 0;x < 400 ; x++){
      y = 0.75x
      dot (x,y,'red')
    }
     法2  其实性能更快 
     while(x<400){
      dot(x,y)
      x+=1
      y+=0.75*/
  }
  //正方形色彩空间一个面
  //可以不+2变换 可以直接 dot (a/2+200,g/2+100,"rgb(255,"+g+","+b+")")
  var a = 20
  var b = 100
  var r1 = 255 
  var g1 = 255 
  var b1 = 0
  for(j = 100 ; j < 228 ; j++){
    for (i = 20 ; i < 148 ; i++){
      var rgb = "rgb(" + r1 + "," + g1 + "," + b1 + ")"
      dot(a , b , color = rgb)
      a = a + 1
      b1 = b1 + 2
    }
    // document.write("<br>")
    b = b + 1
    a = 20
    b1 = 0
    g1 = g1 - 2
  }
  //矩形
  var c = 150
  var d = 100
  //可以直接在 for条件里声明c、d
  for(j = 100 ; j < 200 ; j++){
    for (i = 20 ; i < 120 ; i++){
      dot(c,d,color='rgb(57,204,204)')
      //"(hsl" + (x+y) +",100%,70%)" x+y 可以为 x*y x-y等
      c = c + 1
    }
    d = d + 1
    c = 150
  }
  // 圆形
  /* 法1 可以遍历画布所有点，画出 距离圆心等于半径的所有点。
  但是半径 和 点到圆心的距离是个差值，并不精确
  但这种遍历的点太多，计算速度慢*/
  /*
  法2 圆的方程 (x-a)^2 + (y-b)^2 = r^2
  根据轨迹方程可以画出两个半圆 拼起来 
  但因为定量的y中x 的数量是一定的，所以 接近x轴的陡度大的地方点会稀疏
   */
  var k = 300
  var l = 150
    // 半径绕360度  求出 两条直角边，半径坐标 加上（减）去这两个长度 ，得到每个点的坐标
  for (i = 0; i < 400 ; i++){
    dot(k,l,color='rgb(255,65,63)')
    k = k + Math.cos(i)*35
    l = l + Math.sin(i)*35
  }
  //椭圆
   var v = 100
  var w = 50
  for (i = 0; i < 400 ; i++){ 
    dot(v,w,color='rgb(255,65,63)')
    v = v + Math.cos(i)*165
    w = w + Math.sin(i)*60
  }
</script>
</html>